{"version":3,"sources":["ui/Table.tsx","parser/MapParser.tsx","ui/OutputDrop.tsx","App.tsx","reportWebVitals.js","index.tsx"],"names":["Table","data","columns","search","sort","pagination","enabled","limit","className","td","th","footer","refreshUI","Promise","r","setTimeout","SubSection","Section","FullName","StartAddress","Size","FullFileName","Additonal","MangledList","AddressSpaceSize","Name","Mangled","FileName","Module","subModuleName","exec","this","subSectionSplit","count","length","a","b","AddressStart","reduce","last","item","subsection_content","match","SUBSECTION_CONTENT","counter","dontCountAnyFollowUp","lastAddress","totalInnerSize","identifier","startsWith","push","trim","addressStart","mangaledName","test","console","debug","MapParser","ADDRESS_HEX_LENGTH","address","parseInt","size","MangledName","log","error","NumRecords","SubSectionsList","section_content","mapParser","SUBSECTION_REGEX","subsection","fileName","subSection","replace","parse","SubSections","getNumRecords","section","currentPos","Sections","Archives","regex","index","lastIndex","key","Archive","CompilationUnit","FileLocation","Symbol","SymbolCall","File","name","hexaddr","slice","hexsize","warn","append","segment","regexList","SEGMENT_STARTS_LIST","parseFunction","undefined","activeSegment","RegExp","ARCHIVE_START","ARCHIVE_REGEX","parseArchiveMatch","bind","SECTION_START","SECTION_REGEX","parseSectionMatch","Regex","join","ParseFunction","content","shift","getSegmentRegex","TurnOnAMPEquality","ADDRESS_MATCHER","SECTION_SIZE_MATCHER","OutputDrop","OnLoaded","useFilePicker","multiple","accept","filesContent","errors","loading","useState","dropLoading","setDropLoading","dropError","setDropError","filesystemError","setFilesystemError","hover","setHover","JSON","stringify","Alert","onClose","severity","AlertTitle","FileDrop","onDrop","files","arrayBuffer","then","buffer","byteLength","Uint8Array","forEach","byte","String","fromCharCode","parser","res","rej","parseFile","catch","err","finally","onDragOver","onDragLeave","Box","sx","p","border","m","justifyContent","justifyItems","Button","disabled","onClick","fullWidth","style","backgroundColor","a11yProps","id","TableSkeleton","Skeleton","animation","height","variant","ModulesTableColumnsOrder","formatter","cell","formatSize","all","KB","Math","floor","MB","AllTableColumnsOrder","DataTableArray","ColumnsOrder","Items","insert","sorted","c","formatToHex","number","toString","App","value","setValue","allData","setAllData","allModules","setAllModules","Container","maxWidth","my","Typography","component","gutterBottom","IconButton","href","color","map","notPartOfArchive","Object","keys","k","sectionKey","subSections","Address","AddressHex","partOfModule","mangled","add","TabContext","borderBottom","borderColor","Tabs","onChange","_event","newValue","Tab","label","TabPanel","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e13f1be7.chunk.js","sourcesContent":["import { Grid } from \"gridjs-react\";\nimport { OneDArray, TColumn } from \"gridjs/dist/src/types\";\nimport { VFC } from \"react\";\nimport \"./Table.css\";\n\ntype ArrayType = string | number;\n\ntype ComponentChild = string | number | bigint | boolean | null | undefined;\n\ntype Props = {\n  data: ArrayType[][];\n  columns: OneDArray<TColumn | string | ComponentChild>;\n};\n\nconst Table: VFC<Props> = ({ data, columns }) => {\n  return (\n    <div>\n      <Grid\n        data={data}\n        columns={columns}\n        search={true}\n        sort={true}\n        pagination={{\n          enabled: true,\n          limit: 200,\n        }}\n        className={{\n          td: \"dense-table-cell light-content\",\n          th: \"dense-table-cell\",\n          footer: \"dense-table-cell\",\n        }}\n      />\n    </div>\n  );\n};\nexport default Table;\n","interface SubSectionSpace {\n  MangledName: string;\n  AddressStart: number;\n  Size: number;\n}\n\n// WIP: Use Worker in the future\nasync function refreshUI() {\n  await new Promise((r) => setTimeout(r, 0));\n}\n\nclass SubSection {\n  public Additonal: string[] = []; // valid but not specifically parser\n  // *(.xyz) options or *fill* -> not further processed for now\n  // mangledSubsectionContent\n  public MangledList: SubSectionSpace[] = [];\n  // -1 = undefined\n  public AddressSpaceSize = -1;\n\n  public Name: string;\n  public Mangled = \"\";\n  public FileName = \"\";\n  public Module = \"\";\n\n  constructor(\n    public Section: string, // Section name\n    public FullName: string, // Subsection name\n    public StartAddress: number, // Start address\n    public Size: number, // Size of subsection\n    public FullFileName: string // Filename\n  ) {\n    // eslint-disable-next-line\n    const subModuleName = /([^\\(]+)\\(([^\\)]+)/g.exec(FullFileName);\n    if (subModuleName) {\n      this.FileName = subModuleName[1] || FullFileName;\n      this.Module = subModuleName[2] || \"\";\n    } else {\n      this.FileName = FullFileName;\n    }\n\n    // eslint-disable-next-line\n    const subSectionSplit = /(\\.[^\\.]+)(.*)/g.exec(FullName);\n    if (subSectionSplit) {\n      this.Name = subSectionSplit[1] || \"\";\n      this.Mangled = subSectionSplit[2] || \"\";\n    } else {\n      this.Name = FullName;\n    }\n  }\n\n  getNumRecords(): number {\n    let count = 0;\n    if (this.Size > 0) {\n      count += 1;\n      if (this.MangledList.length > 0) {\n        // counts any number of records (if mangled name uses own address space)\n        this.MangledList.sort((a, b) => {\n          return a.AddressStart - b.AddressStart;\n        }).reduce((last, item) => {\n          if (last.AddressStart != item.AddressStart) {\n            count++;\n          }\n          return item;\n        });\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Parse subsection content and return number of child sections\n   */\n  parse(subsection_content: string): number {\n    //                         [space]   [* or space]\n    //                                if [---space--] [0x-address--------] [--mangaled name-]\n    //                                if [*][--some--additonal-info-(*fill* or *(.))---]\n    // eslint-disable-next-line\n    const SUBSECTION_CONTENT = /\\n[^\\.\\n](\\*[^\\n]*| +)(0x[0-9a-fA-F]+|[^ ]+)? *([^\\n]*)/gm;\n\n    let match;\n    let counter = 0;\n    let dontCountAnyFollowUp = false;\n    // used to calculate size\n    let lastAddress = 0;\n    let totalInnerSize = 0;\n\n    while ((match = SUBSECTION_CONTENT.exec(subsection_content)) != null) {\n      const identifier = match[1];\n\n      if (!identifier) {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name}`,\n          subsection_content\n        );\n        continue;\n      }\n\n      if (identifier.startsWith(\"*\")) {\n        // found additonal content\n        this.Additonal.push(identifier);\n      } else if (identifier.trim() === \"\") {\n        const addressStart = match[2];\n        const mangaledName = match[3] ? match[3] : \"\";\n\n        // check valid hex\n        if (/^0x([0-9a-fA-F])+$/.test(addressStart)) {\n          // (REFACTOR: cleaner regex needed for identifing)\n          // check if address or size\n          if (addressStart.length == MapParser.ADDRESS_HEX_LENGTH) {\n            // it is an actual address space\n            const address = parseInt(addressStart, 16);\n            let size = 0;\n            if (this.MangledList.length > 0) {\n              size = address - lastAddress;\n            }\n            address - lastAddress;\n            this.MangledList.push({\n              AddressStart: parseInt(addressStart, 16),\n              MangledName: mangaledName,\n              Size: size,\n            });\n            lastAddress = address;\n            totalInnerSize += size;\n\n            // used for amax.exe\n            if (!dontCountAnyFollowUp) {\n              counter += 1;\n            }\n          } else {\n            // it is the size representation\n            // WIP, what todo\n          }\n        } else {\n          // no valid hex provided,\n          // this could be [!provide] value, lets just ignore but inform if not [!provide] - provide can be expected\n          if (\"[!provide]\" !== addressStart.trim()) {\n            console.debug(\n              `Ignoring SubSection content '${addressStart}' in ${this.Section}:${this.Name}`,\n              subsection_content\n            );\n          }\n          // TMP: compatible with AMP.exe\n          dontCountAnyFollowUp = true;\n          continue;\n        }\n      } else {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name} - strange start: '${identifier}' (expected * or ' ')`,\n          subsection_content\n        );\n      }\n\n      // check valid address space\n    }\n\n    // set size of first element\n    if (this.MangledList.length > 0) {\n      if (this.Size - totalInnerSize < 0) {\n        console.error(\n          `Issue while parsing, got negative number? ${\n            this.Size\n          } - ${totalInnerSize} = ${this.Size - totalInnerSize}`,\n          this\n        );\n      } else {\n        this.MangledList[0].Size = this.Size - totalInnerSize;\n      }\n    }\n\n    return counter;\n  }\n}\n\ninterface Archive {\n  Symbol: string;\n  FileLocation: string;\n  CompilationUnit: string;\n  SymbolCall: string;\n}\n\ninterface ArchiveFile {\n  File: string;\n  NumRecords: number;\n  Archives: Archive[];\n}\n\nexport class Section {\n  public NumRecords = 0;\n  // calculated length of address space to next sector\n  public AddressSpaceSize = 0;\n  public SubSectionsList: SubSection[] = [];\n\n  constructor(\n    public Name: string, //\n    public StartAddress: number,\n    public Size: number\n  ) {}\n\n  parse(section_content: string, mapParser: MapParser): SubSection[] {\n    // regex::             [subsection] [0xaddress space] [    0xsize    ]  [ subsection valid aslong '\\n ^.' ]\n    // eslint-disable-next-line\n    const SUBSECTION_REGEX = / (\\.[^ \\t\\n]+|COMMON)\\n? +(0x[0-9a-fA-F]+) +(0x[0-9a-fA-F]+) ?([^\\n]+)?((\\n [^\\.*][^\\n]*)*)/gm;\n\n    // result NumRecords\n    // WIP\n    // console.log(\"parse for section: \", this.Name);\n\n    let match;\n\n    while ((match = SUBSECTION_REGEX.exec(section_content)) != null) {\n      const subsection = match[1];\n      const address = match[2] ? parseInt(match[2]) : 0;\n      const size = match[3] ? parseInt(match[3]) : 0;\n      const fileName = match[4];\n\n      // Amp.exe -> \"only allow paths starting with /\"\n      // for amp.exe equality.\n      // if (!fileName.startsWith(\"/\")) {\n      //   continue;\n      // }\n\n      // WIP add to somewhere\n      const subSection = new SubSection(\n        this.Name,\n        subsection.replace(/\\.text.+/, \"\"),\n        address,\n        size,\n        fileName\n      );\n      if (match[5]) {\n        subSection.parse(match[5]);\n      }\n      this.SubSectionsList.push(subSection);\n      mapParser.SubSections.push(subSection);\n\n      this.NumRecords += subSection.getNumRecords();\n\n      if (subsection === \"COMMON\") {\n        // remove common record (TMP???)\n        this.NumRecords -= 1;\n      }\n    }\n\n    // WIP possible to extend, matching regions with *(.ldata / )\n    return this.SubSectionsList;\n  }\n\n  append(section: Section): void {\n    if (this.StartAddress == 0) {\n      this.StartAddress = section.StartAddress;\n    } else if (section.StartAddress != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a address`\n      );\n    }\n    if (this.Size == 0) {\n      this.Size = section.Size;\n    } else if (section.Size != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a size`\n      );\n    }\n    if (this.NumRecords == 0) {\n      this.NumRecords = section.NumRecords;\n    } else if (section.NumRecords != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - containing records twice`\n      );\n    }\n  }\n}\n\ntype SegmentParseFunction = (\n  match: RegExpExecArray,\n  regex: RegExp,\n  mapParser: MapParser\n) => void;\n\ninterface SegmentInfo {\n  Regex: RegExp;\n  ParseFunction?: SegmentParseFunction;\n  activeSegment?: string;\n}\n\nclass MapParser {\n  private currentPos = 0;\n\n  // Wip, currently, since some stats are handled differently\n  // in the AMAP editor, and it is used as cross testing (expecting at least same results)\n  // this allows to turn \"backward\" compability on for correctness checking.\n  public static TurnOnAMPEquality = false;\n\n  // length of hex address representation, will help parsing\n  public static ADDRESS_HEX_LENGTH = 18;\n\n  // match hex storage address (0xADDRESS(8+))\n  public static ADDRESS_MATCHER = `(0x[0-9a-fA-F]{8,})`;\n  // match section size (0xHEX)\n  public static SECTION_SIZE_MATCHER = `(0x[0-9a-fA-F]+)`;\n\n  // Be aware, for string regex, following need a '\\' otherwise default string will be used:\n  //-> \\. => \\\\. (enforce . match)\n  //-> \\t => \\\\t (enforce tab match)\n\n  //                             [----section-------] [--0x address----] [---size (opt)--] [---anything till double \\n\\n-]\n  // eslint-disable-next-line\n  public static SECTION_REGEX = `\\n(\\\\.[^ \\n\\\\t]+)\\n? *${MapParser.ADDRESS_MATCHER}? *${MapParser.SECTION_SIZE_MATCHER}?([^\\n]*(\\n [^\\n]*)*)`;\n\n  //                            [archive-path] (-Symbol-)\\n  [CompileUnit](--Call--)\n  // eslint-disable-next-line\n  public static ARCHIVE_REGEX = `\\n([^\\\\(\\n ]+)\\\\(([^\\\\)]+)\\\\)\\n +([^\\n ]+) +([^\\n]+)`;\n\n  public static ARCHIVE_START = `Archive member included to satisfy reference by file[^\\n]*`;\n  public static SECTION_START = `Linker script and memory map[^\\n]*`;\n\n  // list of starts of new region within the output.map file\n  public static SEGMENT_STARTS_LIST = [\n    MapParser.ARCHIVE_START,\n    `Merging program properties[^\\n]*`,\n    `Discarded input sections[^\\n]*`,\n    `Memory Configuration[^\\n]*`,\n    MapParser.SECTION_START,\n  ];\n\n  public Sections: {\n    [key: string]: Section;\n  } = {};\n  public SubSections: SubSection[] = [];\n  public Archives: {\n    [ArchiveFile: string]: ArchiveFile;\n  } = {};\n\n  private parseArchiveMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length < 4) {\n      console.log(\n        `Unexpected parsing at character ${match.index} - ${regex.lastIndex}`,\n        match[0]\n      );\n    }\n\n    const key = `${match[1]}`;\n    const Archive = {\n      CompilationUnit: match[3],\n      FileLocation: match[1],\n      Symbol: match[2],\n      SymbolCall: match[4],\n    };\n\n    if (!this.Archives[key]) {\n      this.Archives[key] = {\n        Archives: [],\n        File: Archive.FileLocation,\n        NumRecords: 0,\n      };\n    }\n\n    this.Archives[key].NumRecords++;\n    this.Archives[key].Archives.push(Archive);\n  }\n\n  private parseSectionMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length <= 4) {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n      return;\n    }\n\n    if (match.length >= 3) {\n      const name = match[1];\n      const hexaddr = match[2]?.slice(2);\n      const hexsize = match[3]?.slice(2);\n\n      if (!name || (!hexaddr && hexsize) || (hexaddr && !hexsize)) {\n        console.warn(\n          `possible parsing error at character ${match.index} - ${regex.lastIndex}`\n        );\n        return;\n      }\n\n      const section = new Section(\n        name,\n        hexaddr ? parseInt(hexaddr, 16) : 0,\n        hexsize ? parseInt(hexsize, 16) : 0\n      );\n      section.parse(match[4], this);\n      if (this.Sections[name]) {\n        this.Sections[name].append(section);\n      } else {\n        this.Sections[name] = section;\n      }\n    } else {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n    }\n  }\n\n  private getSegmentRegex(segment: string): SegmentInfo {\n    const regexList = MapParser.SEGMENT_STARTS_LIST.slice();\n    let parseFunction = undefined;\n    let activeSegment = undefined;\n\n    if (new RegExp(MapParser.ARCHIVE_START, \"g\").test(segment)) {\n      activeSegment = \"ARCHIVE\";\n      regexList.push(MapParser.ARCHIVE_REGEX);\n      parseFunction = this.parseArchiveMatch.bind(this);\n    } else if (new RegExp(MapParser.SECTION_START, \"g\").test(segment)) {\n      activeSegment = \"SECTION\";\n      regexList.push(MapParser.SECTION_REGEX);\n      parseFunction = this.parseSectionMatch.bind(this);\n    } else {\n      // WIP, ignore any other segment for now\n      // console.debug(`WIP: skip ${segment}`);\n    }\n    return {\n      Regex: new RegExp(`(${regexList.join(\"|\")})`, \"gm\"),\n      ParseFunction: parseFunction,\n      activeSegment: activeSegment,\n    };\n  }\n\n  async parse(content: string): Promise<void> {\n    let activeSegment: SegmentInfo = {\n      Regex: new RegExp(`(${MapParser.SEGMENT_STARTS_LIST.join(\"|\")})`, \"gm\"),\n      activeSegment: \"START\",\n    };\n\n    let match: RegExpExecArray | null;\n    while ((match = activeSegment.Regex.exec(content)) !== null) {\n      const next_match = match[2];\n\n      if (next_match) {\n        match.shift(); // access actual match\n\n        if (activeSegment.ParseFunction) {\n          activeSegment.ParseFunction(match, activeSegment.Regex, this);\n        } else {\n          console.debug(\n            \"unexpected match, no parsing function provided\",\n            match[0]\n          );\n        }\n      } else {\n        // replace active regex\n        const index = activeSegment.Regex.lastIndex;\n        activeSegment = this.getSegmentRegex(match[1]);\n        activeSegment.Regex.lastIndex = index;\n      }\n\n      // WIP: update state??\n      await refreshUI();\n    }\n  }\n}\n\nexport default MapParser;\n","import { Alert, AlertTitle, Box, Button } from \"@material-ui/core\";\nimport { useState, VFC } from \"react\";\nimport { FileDrop } from \"react-file-drop\";\nimport { useFilePicker } from \"use-file-picker\";\nimport MapParser from \"../parser/MapParser\";\n\nfunction parseFile(files: FileList | null): Promise<MapParser> {\n  if (files?.length === 1) {\n    const file = files.item(0) as File;\n\n    return file.arrayBuffer().then(async (buffer: ArrayBuffer) => {\n      // do things\n      console.log(\"lets work on the file size: \", buffer.byteLength);\n\n      let content = \"\";\n      new Uint8Array(buffer).forEach((byte: number) => {\n        content += String.fromCharCode(byte);\n      });\n\n      const parser = new MapParser();\n      await parser.parse(content);\n      return parser;\n    });\n  } else {\n    return new Promise((res, rej) => {\n      rej(\"provide one file!\");\n      console.error(files);\n    });\n  }\n}\n\ntype Props = {\n  OnLoaded: (mapParser: MapParser) => void;\n};\n\nconst OutputDrop: VFC<Props> = ({ OnLoaded }) => {\n  const [filesContent, errors, openFileSelector, loading] = useFilePicker({\n    multiple: false,\n    // accept: '.ics,.pdf',\n    accept: [\".map\"],\n  });\n  // TMP\n  openFileSelector;\n  const [dropLoading, setDropLoading] = useState(false);\n  const [dropError, setDropError] = useState<boolean | string>(false);\n  const [filesystemError, setFilesystemError] = useState<boolean | string>(\n    false\n  );\n  const [hover, setHover] = useState(false);\n\n  if (filesContent[0]) {\n    console.log(\n      \"loading through filesystem currently not supported!\",\n      JSON.stringify(filesContent)\n    );\n  }\n\n  return (\n    <div>\n      {errors.length > 0 ? (\n        <Alert onClose={() => (errors.length = 0)} severity=\"error\">\n          <AlertTitle>Error occured while opening file!</AlertTitle>\n          {JSON.stringify(errors)}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {filesystemError ? (\n        <Alert onClose={() => setFilesystemError(false)} severity=\"warning\">\n          <AlertTitle>{filesystemError}</AlertTitle>\n          Drop the file onto the region.\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {dropError ? (\n        <Alert onClose={() => setDropError(false)} severity=\"error\">\n          <AlertTitle>Loading Dropped file failed!</AlertTitle>\n          {dropError}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      <FileDrop\n        onDrop={(files) => {\n          setDropLoading(true);\n          // lets run in background\n          parseFile(files)\n            .then(OnLoaded)\n            .catch((err) => setDropError(err))\n            .finally(() => setDropLoading(false));\n        }}\n        onDragOver={() => {\n          if (!hover) {\n            setHover(true);\n            console.log(\"setHover(true)\");\n          }\n        }}\n        onDragLeave={() => {\n          if (hover) {\n            setHover(false);\n            console.log(\"setHover(false)\");\n          }\n        }}\n      >\n        <Box\n          sx={{ p: 0, border: \"1px dashed grey\", m: \"auto\" }}\n          justifyContent=\"center\"\n          justifyItems=\"center\"\n        >\n          <Button\n            disabled={loading || dropLoading}\n            onClick={() => {\n              // openFileSelector()\n              setFilesystemError(\"openFileSelector currently not supported\");\n            }}\n            sx={{ p: 3, m: \"auto\" }}\n            fullWidth={true}\n            style={\n              hover\n                ? {\n                    backgroundColor: \"rgba(63, 81, 181, 0.04)\",\n                  }\n                : {}\n            }\n          >\n            {loading || dropLoading\n              ? \"Loading ... (Will currently block any interaction)\"\n              : \"Drop output.map here\"}\n          </Button>\n        </Box>\n      </FileDrop>\n    </div>\n  );\n};\n\nexport default OutputDrop;\n","import { SyntheticEvent, useState, VFC } from \"react\";\nimport \"./App.css\";\nimport {\n  Box,\n  Container,\n  Tab,\n  Tabs,\n  Typography,\n  Skeleton,\n  IconButton,\n} from \"@material-ui/core\";\nimport Table from \"./ui/Table\";\nimport OutputDrop from \"./ui/OutputDrop\";\nimport MapParser from \"./parser/MapParser\";\nimport { TCell } from \"gridjs/dist/src/types\";\nimport { TabContext, TabPanel } from \"@mui/lab\";\nimport CloudDownloadIcon from \"@mui/icons-material/CloudDownload\";\n\nfunction a11yProps(index: number) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\n\nconst TableSkeleton: VFC = () => {\n  return (\n    <div>\n      <Skeleton animation={false} height={64} />\n      <Skeleton variant=\"rectangular\" animation={false} height={500} />\n    </div>\n  );\n};\n\ntype ModulesTableColumns = {\n  Module: string;\n  \"Size no .bss\": number;\n  Size: number;\n  \"Num of records\": number;\n};\ntype ByFilesTableColumns = {\n  File: string;\n} & ModulesTableColumns;\nconst ModulesTableColumnsOrder = [\n  \"Module\",\n  \"Size no .bss\",\n  {\n    name: \"Size\",\n    formatter: (cell: TCell) => formatSize(cell as number),\n  },\n  \"Num of records\",\n];\n\nconst formatSize = (size: number) => {\n  const all = size;\n  const B = size % 1000;\n  size -= B;\n  const KB = Math.floor((size / 1000) % 1000);\n  size -= KB;\n  const MB = Math.floor(size / 1000 / 1000);\n\n  if (MB > 0) {\n    return `${all} (+${MB}M)`;\n  }\n  if (KB > 0) {\n    return `${all} (+${KB}K)`;\n  }\n  return `${all}`;\n};\n\ntype AllTableColumns = {\n  Section: string;\n  SubSection: string;\n  Address: number;\n  AddressHex: string;\n  Size: number;\n  \"Demangled Name\": string;\n  \"Moduled Name\": string;\n  \"File Name\": string;\n  \"Mandled Name\": string;\n};\nconst AllTableColumnsOrder = [\n  \"Section\",\n  \"SubSection\",\n  \"AddressHex\",\n  {\n    name: \"Size\",\n    formatter: (cell: TCell) => formatSize(cell as number),\n  },\n  \"Demangled Name\",\n  \"Moduled Name\",\n  \"File Name\",\n  \"Mandled Name\",\n];\n\ntype TableContentType = string | number;\n\nclass DataTableArray<T extends Record<string, TableContentType>> {\n  Items: TableContentType[][] = [];\n\n  constructor(public ColumnsOrder: string[]) {}\n\n  add(insert: T) {\n    const sorted: TableContentType[] = [];\n    this.ColumnsOrder.forEach((c) => {\n      sorted.push(insert[c]);\n    });\n    this.Items.push(sorted);\n  }\n}\n\nconst formatToHex = (number: number) => {\n  return \"0x\" + `0000000000000000${number.toString(16)}`.slice(-16);\n};\n\nconst App: VFC = () => {\n  const [value, setValue] = useState(\"all\");\n\n  const [allData, setAllData] = useState<TableContentType[][]>([]);\n  const [allModules, setAllModules] = useState<TableContentType[][]>([]);\n\n  const handleChange = (_event: SyntheticEvent, newValue: string) => {\n    setValue(newValue);\n  };\n\n  const fillDatabase = (parser: MapParser) => {\n    const all = new DataTableArray<AllTableColumns>(\n      // eslint-disable-next-line\n      AllTableColumnsOrder.map((c: any) => {\n        return c.name || c;\n      })\n    );\n    const allModules = new DataTableArray<ModulesTableColumns>(\n      // eslint-disable-next-line\n      ModulesTableColumnsOrder.map((c: any) => {\n        return c.name || c;\n      })\n    );\n    // const byfiles = new\n\n    const notPartOfArchive: ModulesTableColumns = {\n      \"Num of records\": 0,\n      \"Size no .bss\": -1,\n      Module: \"\",\n      Size: 0,\n    };\n    const Archives: { [key: string]: ByFilesTableColumns } = {};\n    Object.keys(parser.Archives).forEach((k) => {\n      Archives[k] = {\n        \"Num of records\": 0,\n        \"Size no .bss\": -1,\n        Module: k,\n        Size: 0,\n        File: parser.Archives[k].File,\n      };\n    });\n\n    // fill all view data\n    // Wip fill module / archive categorisation\n    Object.keys(parser.Sections).forEach((sectionKey) => {\n      parser.Sections[sectionKey].SubSectionsList.forEach((subSections) => {\n        const insert: AllTableColumns = {\n          \"Demangled Name\": \"\",\n          \"File Name\": subSections.FileName,\n          \"Mandled Name\": subSections.Mangled.replace(/$\\.(text|data)/g, \"\"),\n          Address: subSections.StartAddress,\n          AddressHex: formatToHex(subSections.StartAddress),\n          Section: subSections.Section,\n          SubSection: subSections.Name,\n          Size: subSections.Size,\n          \"Moduled Name\": \"\",\n        };\n\n        // WIP, move to parsing process??\n        // select archive for process\n        let partOfModule: ModulesTableColumns = Archives[subSections.FileName];\n        if (!partOfModule) {\n          partOfModule = notPartOfArchive;\n        }\n\n        partOfModule.Size += subSections.Size;\n\n        if (subSections.MangledList.length > 0) {\n          subSections.MangledList.forEach((mangled) => {\n            insert[\"Mandled Name\"] = mangled.MangledName;\n            insert.Size = mangled.Size;\n\n            insert.Address = mangled.AddressStart;\n            insert.AddressHex = formatToHex(mangled.AddressStart);\n            all.add(insert);\n\n            if (mangled.Size > 0) {\n              partOfModule[\"Num of records\"]++;\n            }\n          });\n        } else {\n          if (subSections.Size > 0) {\n            partOfModule[\"Num of records\"]++;\n          }\n\n          all.add(insert);\n        }\n      });\n    });\n\n    allModules.add(notPartOfArchive);\n    Object.keys(Archives).forEach((key) => {\n      // modules.add(Archives[key]) => byFile\n      allModules.add({\n        \"Num of records\": Archives[key][\"Num of records\"],\n        \"Size no .bss\": Archives[key][\"Size no .bss\"],\n        Module: Archives[key].Module,\n        Size: Archives[key].Size,\n      });\n    });\n\n    //console.log(\"res ...\", parser.Archives);\n    setAllData(all.Items);\n    setAllModules(allModules.Items);\n  };\n\n  return (\n    <Container maxWidth=\"lg\">\n      <Box my={4}>\n        <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n          <IconButton href=\"./gcc-output-map-web-renderer.zip\">\n            <CloudDownloadIcon color=\"action\" />\n          </IconButton>\n          output.map viewer\n        </Typography>\n\n        <OutputDrop OnLoaded={fillDatabase} />\n\n        <TabContext value={value}>\n          <Box sx={{ borderBottom: 1, borderColor: \"divider\" }}>\n            <Tabs\n              value={value}\n              onChange={handleChange}\n              aria-label=\"basic tabs example\"\n            >\n              <Tab label=\"All\" value=\"all\" {...a11yProps(0)} />\n              <Tab label=\"By Module\" value=\"by_module\" {...a11yProps(1)} />\n              <Tab label=\"By File (WIP)\" value=\"by_file\" {...a11yProps(2)} />\n              <Tab\n                label=\"By Section (WIP)\"\n                value=\"by_section\"\n                {...a11yProps(3)}\n              />\n              <Tab\n                label=\"By SubSection (WIP)\"\n                value=\"by_subsection\"\n                {...a11yProps(4)}\n              />\n            </Tabs>\n          </Box>\n          <TabPanel value=\"all\">\n            <Table data={allData} columns={AllTableColumnsOrder} />\n          </TabPanel>\n          <TabPanel value=\"by_module\">\n            <Table data={allModules} columns={ModulesTableColumnsOrder} />\n          </TabPanel>\n          <TabPanel value=\"by_file\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_section\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_subsection\">\n            <TableSkeleton />\n          </TabPanel>\n        </TabContext>\n      </Box>\n    </Container>\n  );\n};\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}