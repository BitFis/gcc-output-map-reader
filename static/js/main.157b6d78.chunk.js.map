{"version":3,"sources":["ui/Table.tsx","parser/MapParser.tsx","ui/OutputDrop.tsx","App.tsx","reportWebVitals.js","index.tsx"],"names":["Table","data","columns","search","pagination","enabled","limit","className","td","th","footer","SubSection","Section","Name","StartAddress","Size","FileName","Additonal","MangledList","AddressSpaceSize","count","this","length","sort","a","b","AddressStart","reduce","last","item","subsection_content","match","SUBSECTION_CONTENT","counter","dontCountAnyFollowUp","exec","identifier","startsWith","push","trim","addressStart","mangaledName","test","console","debug","MapParser","ADDRESS_HEX_LENGTH","parseInt","MangledName","log","NumRecords","section_content","SUBSECTION_REGEX","subSectionsList","subsection","address","size","fileName","subSection","parse","getNumRecords","section","currentPos","Sections","Archives","regex","index","lastIndex","Archive","CompilationUnit","FileLocation","Symbol","SymbolCall","File","name","hexaddr","slice","hexsize","warn","append","segment","regexList","SEGMENT_STARTS_LIST","parseFunction","undefined","activeSegment","RegExp","ARCHIVE_START","ARCHIVE_REGEX","parseArchiveMatch","bind","SECTION_START","SECTION_REGEX","parseSectionMatch","Regex","join","ParseFunction","content","shift","getSegmentRegex","TurnOnAMPEquality","ADDRESS_MATCHER","SECTION_SIZE_MATCHER","OutputDrop","useFilePicker","multiple","accept","filesContent","errors","loading","useState","dropLoading","setDropLoading","dropError","setDropError","filesystemError","setFilesystemError","hover","setHover","JSON","stringify","Alert","onClose","severity","AlertTitle","FileDrop","onDrop","files","arrayBuffer","then","buffer","byteLength","Uint8Array","forEach","byte","String","fromCharCode","parser","Object","keys","Promise","res","rej","error","parseFile","catch","err","finally","onDragOver","onDragLeave","Box","sx","p","border","m","justifyContent","justifyItems","Button","disabled","onClick","fullWidth","style","backgroundColor","a11yProps","id","TableSkeleton","Skeleton","animation","height","variant","App","value","setValue","Container","maxWidth","my","Typography","component","gutterBottom","TabContext","borderBottom","borderColor","Tabs","onChange","_event","newValue","aria-label","Tab","label","TabPanel","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.157b6d78.chunk.js","sourcesContent":["import { Grid } from \"gridjs-react\";\nimport { VFC } from \"react\";\nimport \"./Table.css\";\n\nconst Table: VFC = () => {\n  return (\n    <div>\n      <Grid\n        data={[\n          [\"\", 105000, 105000, 2311],\n          [\" Source/libCTestLib.a\", 1993516, 1994816, 10279],\n        ]}\n        columns={[\"Module\", \"Size no .bss\", \"Size\", \"Num of records\"]}\n        search={true}\n        pagination={{\n          enabled: true,\n          limit: 100,\n        }}\n        className={{\n          td: \"dense-table-cell light-content\",\n          th: \"dense-table-cell\",\n          footer: \"dense-table-cell\",\n        }}\n      />\n    </div>\n  );\n};\nexport default Table;\n","interface SubSectionSpace {\n  MangledName: string;\n  AddressStart: number;\n}\n\nclass SubSection {\n  public Additonal: string[] = []; // valid but not specifically parser\n  // *(.xyz) options or *fill* -> not further processed for now\n  // mangledSubsectionContent\n  public MangledList: SubSectionSpace[] = [];\n  // -1 = undefined\n  public AddressSpaceSize = -1;\n\n  constructor(\n    public Section: string, // Section name\n    public Name: string, // Subsection name\n    public StartAddress: number, // Start address\n    public Size: number, // Size of subsection\n    public FileName: string // Filename\n  ) {}\n\n  getNumRecords(): number {\n    let count = 0;\n    if (this.Size > 0) {\n      count += 1;\n      if (this.MangledList.length > 0) {\n        // counts any number of records (if mangled name uses own address space)\n        this.MangledList.sort((a, b) => {\n          return a.AddressStart - b.AddressStart;\n        }).reduce((last, item) => {\n          if (last.AddressStart != item.AddressStart) {\n            count++;\n          }\n          return item;\n        });\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Parse subsection content and return number of child sections\n   */\n  parse(subsection_content: string): number {\n    //                         [space]   [* or space]\n    //                                if [---space--] [0x-address--------] [--mangaled name-]\n    //                                if [*][--some--additonal-info-(*fill* or *(.))---]\n    // eslint-disable-next-line\n    const SUBSECTION_CONTENT = /\\n[^\\.\\n](\\*[^\\n]*| +)(0x[0-9a-fA-F]+|[^ ]+)? *([^\\n]*)/gm;\n\n    let match;\n    let counter = 0;\n    let dontCountAnyFollowUp = false;\n\n    while ((match = SUBSECTION_CONTENT.exec(subsection_content)) != null) {\n      const identifier = match[1];\n\n      if (!identifier) {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name}`,\n          subsection_content\n        );\n        continue;\n      }\n\n      if (identifier.startsWith(\"*\")) {\n        // found additonal content\n        this.Additonal.push(identifier);\n      } else if (identifier.trim() === \"\") {\n        const addressStart = match[2];\n        const mangaledName = match[3] ? match[3] : \"\";\n\n        // check valid hex\n        if (/^0x([0-9a-fA-F])+$/.test(addressStart)) {\n          // (REFACTOR: cleaner regex needed for identifing)\n          // check if address or size\n          if (addressStart.length == MapParser.ADDRESS_HEX_LENGTH) {\n            // it is an actual address space\n            this.MangledList.push({\n              AddressStart: parseInt(addressStart, 16),\n              MangledName: mangaledName,\n            });\n\n            // used for amax.exe\n            if (!dontCountAnyFollowUp) {\n              counter += 1;\n            }\n          } else {\n            // it is the size representation\n            // WIP, what todo\n          }\n        } else {\n          // no valid hex provided,\n          // this could be [!provide] value, lets just ignore but inform if not [!provide] - provide can be expected\n          if (\"[!provide]\" !== addressStart.trim()) {\n            console.debug(\n              `Ignoring SubSection content '${addressStart}' in ${this.Section}:${this.Name}`,\n              subsection_content\n            );\n          }\n          // TMP: compatible with AMP.exe\n          dontCountAnyFollowUp = true;\n          continue;\n        }\n      } else {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name} - strange start: '${identifier}' (expected * or ' ')`,\n          subsection_content\n        );\n      }\n\n      // check valid address space\n    }\n\n    return counter;\n  }\n}\n\ninterface Archive {\n  Symbol: string;\n  FileLocation: string;\n  CompilationUnit: string;\n  SymbolCall: string;\n}\n\ninterface ArchiveFile {\n  File: string;\n  NumRecords: number;\n  Archives: Archive[];\n}\n\nclass Section {\n  public NumRecords = 0;\n  // calculated length of address space to next sector\n  public AddressSpaceSize = 0;\n\n  constructor(\n    public Name: string, //\n    public StartAddress: number,\n    public Size: number\n  ) {}\n\n  parse(section_content: string): SubSection[] {\n    // regex::             [subsection] [0xaddress space] [    0xsize    ]  [ subsection valid aslong '\\n ^.' ]\n    // eslint-disable-next-line\n    const SUBSECTION_REGEX = / (\\.[^ \\t\\n]+)\\n? +(0x[0-9a-fA-F]+) +(0x[0-9a-fA-F]+) ?([^\\n]+)?((\\n [^\\.][^\\n]*)*)/gm;\n\n    // result NumRecords\n    // WIP\n    // console.log(\"parse for section: \", this.Name);\n\n    const subSectionsList: SubSection[] = [];\n    let match;\n\n    while ((match = SUBSECTION_REGEX.exec(section_content)) != null) {\n      const subsection = match[1];\n      const address = match[2] ? parseInt(match[2]) : 0;\n      const size = match[3] ? parseInt(match[3]) : 0;\n      const fileName = match[4];\n\n      // Amp.exe -> \"only allow paths starting with /\"\n      // for amp.exe equality.\n      // if (!fileName.startsWith(\"/\")) {\n      //   continue;\n      // }\n\n      // WIP add to somewhere\n      const subSection = new SubSection(\n        this.Name,\n        subsection,\n        address,\n        size,\n        fileName\n      );\n      if (match[5]) {\n        subSection.parse(match[5]);\n      }\n      subSectionsList.push(subSection);\n\n      this.NumRecords += subSection.getNumRecords();\n    }\n\n    // WIP possible to extend, matching regions with *(.ldata / )\n    return subSectionsList;\n  }\n\n  append(section: Section) {\n    if (this.StartAddress == 0) {\n      this.StartAddress = section.StartAddress;\n    } else if (section.StartAddress != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a address`\n      );\n    }\n    if (this.Size == 0) {\n      this.Size = section.Size;\n    } else if (section.Size != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a size`\n      );\n    }\n    if (this.NumRecords == 0) {\n      this.NumRecords = section.NumRecords;\n    } else if (section.NumRecords != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - containing records twice`\n      );\n    }\n  }\n}\n\ntype SegmentParseFunction = (\n  match: RegExpExecArray,\n  regex: RegExp,\n  mapParser: MapParser\n) => void;\n\ninterface SegmentInfo {\n  Regex: RegExp;\n  ParseFunction?: SegmentParseFunction;\n  activeSegment?: string;\n}\n\nclass MapParser {\n  private currentPos = 0;\n\n  // Wip, currently, since some stats are handled differently\n  // in the AMAP editor, and it is used as cross testing (expecting at least same results)\n  // this allows to turn \"backward\" compability on for correctness checking.\n  public static TurnOnAMPEquality = false;\n\n  // length of hex address representation, will help parsing\n  public static ADDRESS_HEX_LENGTH = 18;\n\n  // match hex storage address (0xADDRESS(8+))\n  public static ADDRESS_MATCHER = `(0x[0-9a-fA-F]{8,})`;\n  // match section size (0xHEX)\n  public static SECTION_SIZE_MATCHER = `(0x[0-9a-fA-F]+)`;\n\n  // Be aware, for string regex, following need a '\\' otherwise default string will be used:\n  //-> \\. => \\\\. (enforce . match)\n  //-> \\t => \\\\t (enforce tab match)\n\n  //                             [----section-------] [--0x address----] [---size (opt)--] [---anything till double \\n\\n-]\n  // eslint-disable-next-line\n  public static SECTION_REGEX = `\\n(\\\\.[^ \\n\\\\t]+)\\n? *${MapParser.ADDRESS_MATCHER}? *${MapParser.SECTION_SIZE_MATCHER}?([^\\n]*(\\n [^\\n]*)*)`;\n\n  //                            [archive-path] (-Symbol-)\\n  [CompileUnit](--Call--)\n  // eslint-disable-next-line\n  public static ARCHIVE_REGEX = `\\n([^\\\\(\\n ]+)\\\\(([^\\\\)]+)\\\\)\\n +([^\\n ]+) +([^\\n]+)`;\n\n  public static ARCHIVE_START = `Archive member included to satisfy reference by file[^\\n]*`;\n  public static SECTION_START = `Linker script and memory map[^\\n]*`;\n\n  // list of starts of new region within the output.map file\n  public static SEGMENT_STARTS_LIST = [\n    MapParser.ARCHIVE_START,\n    `Merging program properties[^\\n]*`,\n    `Discarded input sections[^\\n]*`,\n    `Memory Configuration[^\\n]*`,\n    MapParser.SECTION_START,\n  ];\n\n  public Sections: {\n    [key: string]: Section;\n  } = {};\n  public Archives: {\n    [ArchiveFile: string]: ArchiveFile;\n  } = {};\n\n  private parseArchiveMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length < 4) {\n      console.log(\n        `Unexpected parsing at character ${match.index} - ${regex.lastIndex}`,\n        match[0]\n      );\n    }\n\n    const Archive = {\n      CompilationUnit: match[3],\n      FileLocation: match[1],\n      Symbol: match[2],\n      SymbolCall: match[4],\n    };\n\n    if (!this.Archives[Archive.FileLocation]) {\n      this.Archives[Archive.FileLocation] = {\n        Archives: [],\n        File: Archive.FileLocation,\n        NumRecords: 0,\n      };\n    }\n\n    this.Archives[Archive.FileLocation].NumRecords++;\n    this.Archives[Archive.FileLocation].Archives.push(Archive);\n  }\n\n  private parseSectionMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length <= 4) {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n      return;\n    }\n\n    if (match.length >= 3) {\n      const name = match[1];\n      const hexaddr = match[2]?.slice(2);\n      const hexsize = match[3]?.slice(2);\n\n      if (!name || (!hexaddr && hexsize) || (hexaddr && !hexsize)) {\n        console.warn(\n          `possible parsing error at character ${match.index} - ${regex.lastIndex}`\n        );\n        return;\n      }\n\n      const section = new Section(\n        name,\n        hexaddr ? parseInt(hexaddr, 16) : 0,\n        hexsize ? parseInt(hexsize, 16) : 0\n      );\n      section.parse(match[4]);\n      if (this.Sections[name]) {\n        this.Sections[name].append(section);\n      } else {\n        this.Sections[name] = section;\n      }\n    } else {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n    }\n  }\n\n  private getSegmentRegex(segment: string): SegmentInfo {\n    const regexList = MapParser.SEGMENT_STARTS_LIST.slice();\n    let parseFunction = undefined;\n    let activeSegment = undefined;\n\n    if (new RegExp(MapParser.ARCHIVE_START, \"g\").test(segment)) {\n      activeSegment = \"ARCHIVE\";\n      regexList.push(MapParser.ARCHIVE_REGEX);\n      parseFunction = this.parseArchiveMatch.bind(this);\n    } else if (new RegExp(MapParser.SECTION_START, \"g\").test(segment)) {\n      activeSegment = \"SECTION\";\n      regexList.push(MapParser.SECTION_REGEX);\n      parseFunction = this.parseSectionMatch.bind(this);\n    } else {\n      // WIP, ignore any other segment for now\n      // console.debug(`WIP: skip ${segment}`);\n    }\n    return {\n      Regex: new RegExp(`(${regexList.join(\"|\")})`, \"gm\"),\n      ParseFunction: parseFunction,\n      activeSegment: activeSegment,\n    };\n  }\n\n  parse(content: string): void {\n    let activeSegment: SegmentInfo = {\n      Regex: new RegExp(`(${MapParser.SEGMENT_STARTS_LIST.join(\"|\")})`, \"gm\"),\n      activeSegment: \"START\",\n    };\n\n    let match: RegExpExecArray | null;\n    while ((match = activeSegment.Regex.exec(content)) !== null) {\n      const next_match = match[2];\n\n      if (next_match) {\n        match.shift(); // access actual match\n\n        if (activeSegment.ParseFunction) {\n          activeSegment.ParseFunction(match, activeSegment.Regex, this);\n        } else {\n          console.debug(\n            \"unexpected match, no parsing function provided\",\n            match[0]\n          );\n        }\n      } else {\n        // replace active regex\n        const index = activeSegment.Regex.lastIndex;\n        activeSegment = this.getSegmentRegex(match[1]);\n        activeSegment.Regex.lastIndex = index;\n      }\n    }\n  }\n}\n\nexport default MapParser;\n","import { Alert, AlertTitle, Box, Button } from \"@material-ui/core\";\nimport { useState, VFC } from \"react\";\nimport { FileDrop } from \"react-file-drop\";\nimport { useFilePicker } from \"use-file-picker\";\nimport MapParser from \"../parser/MapParser\";\n\nfunction parseFile(files: FileList | null): Promise<ArrayBuffer> {\n  if (files?.length === 1) {\n    const file = files.item(0) as File;\n\n    return file.arrayBuffer().then((buffer: ArrayBuffer) => {\n      // do things\n      console.log(\"lets work on the file size: \", buffer.byteLength);\n\n      let content = \"\";\n      new Uint8Array(buffer).forEach((byte: number) => {\n        content += String.fromCharCode(byte);\n      });\n\n      const parser = new MapParser();\n      parser.parse(content);\n\n      console.log(Object.keys(parser.Sections));\n\n      return buffer;\n    });\n  } else {\n    return new Promise((res, rej) => {\n      rej(\"provide one file!\");\n      console.error(files);\n    });\n  }\n}\n\nconst OutputDrop: VFC = () => {\n  const [filesContent, errors, openFileSelector, loading] = useFilePicker({\n    multiple: false,\n    // accept: '.ics,.pdf',\n    accept: [\".map\"],\n  });\n  // TMP\n  openFileSelector;\n  const [dropLoading, setDropLoading] = useState(false);\n  const [dropError, setDropError] = useState<boolean | string>(false);\n  const [filesystemError, setFilesystemError] = useState<boolean | string>(\n    false\n  );\n  const [hover, setHover] = useState(false);\n\n  if (filesContent[0]) {\n    console.log(\n      \"loading through filesystem currently not supported!\",\n      JSON.stringify(filesContent)\n    );\n  }\n\n  return (\n    <div>\n      {errors.length > 0 ? (\n        <Alert onClose={() => (errors.length = 0)} severity=\"error\">\n          <AlertTitle>Error occured while opening file!</AlertTitle>\n          {JSON.stringify(errors)}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {filesystemError ? (\n        <Alert onClose={() => setFilesystemError(false)} severity=\"warning\">\n          <AlertTitle>{filesystemError}</AlertTitle>\n          Drop the file onto the region.\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {dropError ? (\n        <Alert onClose={() => setDropError(false)} severity=\"error\">\n          <AlertTitle>Loading Dropped file failed!</AlertTitle>\n          {dropError}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      <FileDrop\n        onDrop={(files) => {\n          setDropLoading(true);\n          parseFile(files)\n            .catch((err) => setDropError(err))\n            .finally(() => setDropLoading(false));\n        }}\n        onDragOver={() => {\n          if (!hover) {\n            setHover(true);\n            console.log(\"setHover(true)\");\n          }\n        }}\n        onDragLeave={() => {\n          if (hover) {\n            setHover(false);\n            console.log(\"setHover(false)\");\n          }\n        }}\n      >\n        <Box\n          sx={{ p: 0, border: \"1px dashed grey\", m: \"auto\" }}\n          justifyContent=\"center\"\n          justifyItems=\"center\"\n        >\n          <Button\n            disabled={loading || dropLoading}\n            onClick={() => {\n              // openFileSelector()\n              setFilesystemError(\"openFileSelector currently not supported\");\n            }}\n            sx={{ p: 3, m: \"auto\" }}\n            fullWidth={true}\n            style={\n              hover\n                ? {\n                    backgroundColor: \"rgba(63, 81, 181, 0.04)\",\n                  }\n                : {}\n            }\n          >\n            {loading || dropLoading ? \"Loading ...\" : \"Drop output.map here\"}\n          </Button>\n        </Box>\n      </FileDrop>\n    </div>\n  );\n};\n\nexport default OutputDrop;\n","import { SyntheticEvent, useState, VFC } from \"react\";\nimport \"./App.css\";\nimport {\n  Box,\n  Container,\n  Tab,\n  Tabs,\n  Typography,\n  Skeleton,\n} from \"@material-ui/core\";\nimport Table from \"./ui/Table\";\nimport { TabContext, TabPanel } from \"@material-ui/lab\";\nimport OutputDrop from \"./ui/OutputDrop\";\n\nfunction a11yProps(index: number) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\n\nconst TableSkeleton: VFC = () => {\n  return (\n    <div>\n      <Skeleton animation={false} height={64} />\n      <Skeleton variant=\"rectangular\" animation={false} height={500} />\n    </div>\n  );\n};\n\nconst App: VFC = () => {\n  const [value, setValue] = useState(\"all\");\n\n  const handleChange = (_event: SyntheticEvent, newValue: string) => {\n    setValue(newValue);\n  };\n\n  return (\n    <Container maxWidth=\"lg\">\n      <Box my={4}>\n        <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n          output.map viewer\n        </Typography>\n\n        <OutputDrop />\n\n        <TabContext value={value}>\n          <Box sx={{ borderBottom: 1, borderColor: \"divider\" }}>\n            <Tabs\n              value={value}\n              onChange={handleChange}\n              aria-label=\"basic tabs example\"\n            >\n              <Tab label=\"All (DEMO)\" value=\"all\" {...a11yProps(0)} />\n              <Tab\n                label=\"By Module (WIP)\"\n                value=\"by_module\"\n                {...a11yProps(1)}\n              />\n              <Tab label=\"By File (WIP)\" value=\"by_file\" {...a11yProps(2)} />\n              <Tab\n                label=\"By Section (WIP)\"\n                value=\"by_section\"\n                {...a11yProps(3)}\n              />\n              <Tab\n                label=\"By SubSection (WIP)\"\n                value=\"by_subsection\"\n                {...a11yProps(4)}\n              />\n            </Tabs>\n          </Box>\n          <TabPanel value=\"all\">\n            <Table />\n          </TabPanel>\n          <TabPanel value=\"by_module\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_file\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_section\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_subsection\">\n            <TableSkeleton />\n          </TabPanel>\n        </TabContext>\n      </Box>\n    </Container>\n  );\n};\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}