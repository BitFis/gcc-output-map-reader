{"version":3,"sources":["ui/Table.tsx","parser/MapParser.tsx","ui/OutputDrop.tsx","App.tsx","reportWebVitals.js","index.tsx"],"names":["Table","data","columns","search","sort","pagination","enabled","limit","className","td","th","footer","SubSection","Section","FullName","StartAddress","Size","FullFileName","Additonal","MangledList","AddressSpaceSize","Name","Mangled","FileName","Module","subModuleName","exec","this","subSectionSplit","count","length","a","b","AddressStart","reduce","last","item","subsection_content","match","SUBSECTION_CONTENT","counter","dontCountAnyFollowUp","lastAddress","totalInnerSize","identifier","startsWith","push","trim","addressStart","mangaledName","test","console","debug","MapParser","ADDRESS_HEX_LENGTH","address","parseInt","size","MangledName","log","NumRecords","SubSectionsList","section_content","mapParser","SUBSECTION_REGEX","subsection","fileName","subSection","replace","parse","SubSections","getNumRecords","section","currentPos","Sections","Archives","regex","index","lastIndex","key","Archive","CompilationUnit","FileLocation","Symbol","SymbolCall","File","name","hexaddr","slice","hexsize","warn","append","segment","regexList","SEGMENT_STARTS_LIST","parseFunction","undefined","activeSegment","RegExp","ARCHIVE_START","ARCHIVE_REGEX","parseArchiveMatch","bind","SECTION_START","SECTION_REGEX","parseSectionMatch","Regex","join","ParseFunction","content","shift","getSegmentRegex","TurnOnAMPEquality","ADDRESS_MATCHER","SECTION_SIZE_MATCHER","OutputDrop","OnLoaded","useFilePicker","multiple","accept","filesContent","errors","loading","useState","dropLoading","setDropLoading","dropError","setDropError","filesystemError","setFilesystemError","hover","setHover","JSON","stringify","Alert","onClose","severity","AlertTitle","FileDrop","onDrop","files","arrayBuffer","then","buffer","byteLength","Uint8Array","forEach","byte","String","fromCharCode","parser","Promise","res","rej","error","parseFile","catch","err","finally","onDragOver","onDragLeave","Box","sx","p","border","m","justifyContent","justifyItems","Button","disabled","onClick","fullWidth","style","backgroundColor","a11yProps","id","TableSkeleton","Skeleton","animation","height","variant","ModulesTableColumnsOrder","AllTableColumnsOrder","DataTableArray","ColumnsOrder","Items","insert","sorted","c","formatToHex","number","toString","App","value","setValue","allData","setAllData","allModules","setAllModules","Container","maxWidth","my","Typography","component","gutterBottom","all","notPartOfArchive","Object","keys","k","sectionKey","subSections","Address","AddressHex","partOfModule","mangled","add","TabContext","borderBottom","borderColor","Tabs","onChange","_event","newValue","aria-label","Tab","label","TabPanel","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f574f681.chunk.js","sourcesContent":["import { Grid } from \"gridjs-react\";\nimport { VFC } from \"react\";\nimport \"./Table.css\";\n\ntype ArrayType = string | number;\n\ntype Props = {\n  data: ArrayType[][];\n  columns: string[];\n};\n\nconst Table: VFC<Props> = ({ data, columns }) => {\n  return (\n    <div>\n      <Grid\n        data={data}\n        columns={columns}\n        search={true}\n        sort={true}\n        pagination={{\n          enabled: true,\n          limit: 200,\n        }}\n        className={{\n          td: \"dense-table-cell light-content\",\n          th: \"dense-table-cell\",\n          footer: \"dense-table-cell\",\n        }}\n      />\n    </div>\n  );\n};\nexport default Table;\n","interface SubSectionSpace {\n  MangledName: string;\n  AddressStart: number;\n  Size: number;\n}\n\nclass SubSection {\n  public Additonal: string[] = []; // valid but not specifically parser\n  // *(.xyz) options or *fill* -> not further processed for now\n  // mangledSubsectionContent\n  public MangledList: SubSectionSpace[] = [];\n  // -1 = undefined\n  public AddressSpaceSize = -1;\n\n  public Name: string;\n  public Mangled = \"\";\n  public FileName = \"\";\n  public Module = \"\";\n\n  constructor(\n    public Section: string, // Section name\n    public FullName: string, // Subsection name\n    public StartAddress: number, // Start address\n    public Size: number, // Size of subsection\n    public FullFileName: string // Filename\n  ) {\n    // eslint-disable-next-line\n    const subModuleName = /([^\\(]+)\\(([^\\)]+)/g.exec(FullFileName);\n    if (subModuleName) {\n      this.FileName = subModuleName[1] || FullFileName;\n      this.Module = subModuleName[2] || \"\";\n    } else {\n      this.FileName = FullFileName;\n    }\n\n    // eslint-disable-next-line\n    const subSectionSplit = /(\\.[^\\.]+)(.*)/g.exec(FullName);\n    if (subSectionSplit) {\n      this.Name = subSectionSplit[1] || \"\";\n      this.Mangled = subSectionSplit[2] || \"\";\n    } else {\n      this.Name = FullName;\n    }\n  }\n\n  getNumRecords(): number {\n    let count = 0;\n    if (this.Size > 0) {\n      count += 1;\n      if (this.MangledList.length > 0) {\n        // counts any number of records (if mangled name uses own address space)\n        this.MangledList.sort((a, b) => {\n          return a.AddressStart - b.AddressStart;\n        }).reduce((last, item) => {\n          if (last.AddressStart != item.AddressStart) {\n            count++;\n          }\n          return item;\n        });\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Parse subsection content and return number of child sections\n   */\n  parse(subsection_content: string): number {\n    //                         [space]   [* or space]\n    //                                if [---space--] [0x-address--------] [--mangaled name-]\n    //                                if [*][--some--additonal-info-(*fill* or *(.))---]\n    // eslint-disable-next-line\n    const SUBSECTION_CONTENT = /\\n[^\\.\\n](\\*[^\\n]*| +)(0x[0-9a-fA-F]+|[^ ]+)? *([^\\n]*)/gm;\n\n    let match;\n    let counter = 0;\n    let dontCountAnyFollowUp = false;\n    // used to calculate size\n    let lastAddress = 0;\n    let totalInnerSize = 0;\n\n    while ((match = SUBSECTION_CONTENT.exec(subsection_content)) != null) {\n      const identifier = match[1];\n\n      if (!identifier) {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name}`,\n          subsection_content\n        );\n        continue;\n      }\n\n      if (identifier.startsWith(\"*\")) {\n        // found additonal content\n        this.Additonal.push(identifier);\n      } else if (identifier.trim() === \"\") {\n        const addressStart = match[2];\n        const mangaledName = match[3] ? match[3] : \"\";\n\n        // check valid hex\n        if (/^0x([0-9a-fA-F])+$/.test(addressStart)) {\n          // (REFACTOR: cleaner regex needed for identifing)\n          // check if address or size\n          if (addressStart.length == MapParser.ADDRESS_HEX_LENGTH) {\n            // it is an actual address space\n            const address = parseInt(addressStart, 16);\n            let size = 0;\n            if (this.MangledList.length > 0) {\n              size = address - lastAddress;\n            }\n            address - lastAddress;\n            this.MangledList.push({\n              AddressStart: parseInt(addressStart, 16),\n              MangledName: mangaledName,\n              Size: size,\n            });\n            lastAddress = address;\n            totalInnerSize += size;\n\n            // used for amax.exe\n            if (!dontCountAnyFollowUp) {\n              counter += 1;\n            }\n          } else {\n            // it is the size representation\n            // WIP, what todo\n          }\n        } else {\n          // no valid hex provided,\n          // this could be [!provide] value, lets just ignore but inform if not [!provide] - provide can be expected\n          if (\"[!provide]\" !== addressStart.trim()) {\n            console.debug(\n              `Ignoring SubSection content '${addressStart}' in ${this.Section}:${this.Name}`,\n              subsection_content\n            );\n          }\n          // TMP: compatible with AMP.exe\n          dontCountAnyFollowUp = true;\n          continue;\n        }\n      } else {\n        console.log(\n          `Potential SubSection parse issue in ${this.Section}:${this.Name} - strange start: '${identifier}' (expected * or ' ')`,\n          subsection_content\n        );\n      }\n\n      // check valid address space\n    }\n\n    // set size of first element\n    if (this.MangledList.length > 0) {\n      this.MangledList[0].Size = this.Size - totalInnerSize;\n    }\n\n    return counter;\n  }\n}\n\ninterface Archive {\n  Symbol: string;\n  FileLocation: string;\n  CompilationUnit: string;\n  SymbolCall: string;\n}\n\ninterface ArchiveFile {\n  File: string;\n  NumRecords: number;\n  Archives: Archive[];\n}\n\nexport class Section {\n  public NumRecords = 0;\n  // calculated length of address space to next sector\n  public AddressSpaceSize = 0;\n  public SubSectionsList: SubSection[] = [];\n\n  constructor(\n    public Name: string, //\n    public StartAddress: number,\n    public Size: number\n  ) {}\n\n  parse(section_content: string, mapParser: MapParser): SubSection[] {\n    // regex::             [subsection] [0xaddress space] [    0xsize    ]  [ subsection valid aslong '\\n ^.' ]\n    // eslint-disable-next-line\n    const SUBSECTION_REGEX = / (\\.[^ \\t\\n]+)\\n? +(0x[0-9a-fA-F]+) +(0x[0-9a-fA-F]+) ?([^\\n]+)?((\\n [^\\.][^\\n]*)*)/gm;\n\n    // result NumRecords\n    // WIP\n    // console.log(\"parse for section: \", this.Name);\n\n    let match;\n\n    while ((match = SUBSECTION_REGEX.exec(section_content)) != null) {\n      const subsection = match[1];\n      const address = match[2] ? parseInt(match[2]) : 0;\n      const size = match[3] ? parseInt(match[3]) : 0;\n      const fileName = match[4];\n\n      // Amp.exe -> \"only allow paths starting with /\"\n      // for amp.exe equality.\n      // if (!fileName.startsWith(\"/\")) {\n      //   continue;\n      // }\n\n      // WIP add to somewhere\n      const subSection = new SubSection(\n        this.Name,\n        subsection.replace(/\\.text.+/, \"\"),\n        address,\n        size,\n        fileName\n      );\n      if (match[5]) {\n        subSection.parse(match[5]);\n      }\n      this.SubSectionsList.push(subSection);\n      mapParser.SubSections.push(subSection);\n\n      this.NumRecords += subSection.getNumRecords();\n    }\n\n    // WIP possible to extend, matching regions with *(.ldata / )\n    return this.SubSectionsList;\n  }\n\n  append(section: Section): void {\n    if (this.StartAddress == 0) {\n      this.StartAddress = section.StartAddress;\n    } else if (section.StartAddress != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a address`\n      );\n    }\n    if (this.Size == 0) {\n      this.Size = section.Size;\n    } else if (section.Size != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - section exists twice with a size`\n      );\n    }\n    if (this.NumRecords == 0) {\n      this.NumRecords = section.NumRecords;\n    } else if (section.NumRecords != 0) {\n      console.log(\n        `undefined behaviour, joining section ${section.Name} - containing records twice`\n      );\n    }\n  }\n}\n\ntype SegmentParseFunction = (\n  match: RegExpExecArray,\n  regex: RegExp,\n  mapParser: MapParser\n) => void;\n\ninterface SegmentInfo {\n  Regex: RegExp;\n  ParseFunction?: SegmentParseFunction;\n  activeSegment?: string;\n}\n\nclass MapParser {\n  private currentPos = 0;\n\n  // Wip, currently, since some stats are handled differently\n  // in the AMAP editor, and it is used as cross testing (expecting at least same results)\n  // this allows to turn \"backward\" compability on for correctness checking.\n  public static TurnOnAMPEquality = false;\n\n  // length of hex address representation, will help parsing\n  public static ADDRESS_HEX_LENGTH = 18;\n\n  // match hex storage address (0xADDRESS(8+))\n  public static ADDRESS_MATCHER = `(0x[0-9a-fA-F]{8,})`;\n  // match section size (0xHEX)\n  public static SECTION_SIZE_MATCHER = `(0x[0-9a-fA-F]+)`;\n\n  // Be aware, for string regex, following need a '\\' otherwise default string will be used:\n  //-> \\. => \\\\. (enforce . match)\n  //-> \\t => \\\\t (enforce tab match)\n\n  //                             [----section-------] [--0x address----] [---size (opt)--] [---anything till double \\n\\n-]\n  // eslint-disable-next-line\n  public static SECTION_REGEX = `\\n(\\\\.[^ \\n\\\\t]+)\\n? *${MapParser.ADDRESS_MATCHER}? *${MapParser.SECTION_SIZE_MATCHER}?([^\\n]*(\\n [^\\n]*)*)`;\n\n  //                            [archive-path] (-Symbol-)\\n  [CompileUnit](--Call--)\n  // eslint-disable-next-line\n  public static ARCHIVE_REGEX = `\\n([^\\\\(\\n ]+)\\\\(([^\\\\)]+)\\\\)\\n +([^\\n ]+) +([^\\n]+)`;\n\n  public static ARCHIVE_START = `Archive member included to satisfy reference by file[^\\n]*`;\n  public static SECTION_START = `Linker script and memory map[^\\n]*`;\n\n  // list of starts of new region within the output.map file\n  public static SEGMENT_STARTS_LIST = [\n    MapParser.ARCHIVE_START,\n    `Merging program properties[^\\n]*`,\n    `Discarded input sections[^\\n]*`,\n    `Memory Configuration[^\\n]*`,\n    MapParser.SECTION_START,\n  ];\n\n  public Sections: {\n    [key: string]: Section;\n  } = {};\n  public SubSections: SubSection[] = [];\n  public Archives: {\n    [ArchiveFile: string]: ArchiveFile;\n  } = {};\n\n  private parseArchiveMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length < 4) {\n      console.log(\n        `Unexpected parsing at character ${match.index} - ${regex.lastIndex}`,\n        match[0]\n      );\n    }\n\n    const key = `${match[1]}`;\n    const Archive = {\n      CompilationUnit: match[3],\n      FileLocation: match[1],\n      Symbol: match[2],\n      SymbolCall: match[4],\n    };\n\n    if (!this.Archives[key]) {\n      this.Archives[key] = {\n        Archives: [],\n        File: Archive.FileLocation,\n        NumRecords: 0,\n      };\n    }\n\n    this.Archives[key].NumRecords++;\n    this.Archives[key].Archives.push(Archive);\n  }\n\n  private parseSectionMatch(match: RegExpExecArray, regex: RegExp) {\n    if (match.length <= 4) {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n      return;\n    }\n\n    if (match.length >= 3) {\n      const name = match[1];\n      const hexaddr = match[2]?.slice(2);\n      const hexsize = match[3]?.slice(2);\n\n      if (!name || (!hexaddr && hexsize) || (hexaddr && !hexsize)) {\n        console.warn(\n          `possible parsing error at character ${match.index} - ${regex.lastIndex}`\n        );\n        return;\n      }\n\n      const section = new Section(\n        name,\n        hexaddr ? parseInt(hexaddr, 16) : 0,\n        hexsize ? parseInt(hexsize, 16) : 0\n      );\n      section.parse(match[4], this);\n      if (this.Sections[name]) {\n        this.Sections[name].append(section);\n      } else {\n        this.Sections[name] = section;\n      }\n    } else {\n      console.log(`parser error at: ${match.index} ${regex.lastIndex}`);\n    }\n  }\n\n  private getSegmentRegex(segment: string): SegmentInfo {\n    const regexList = MapParser.SEGMENT_STARTS_LIST.slice();\n    let parseFunction = undefined;\n    let activeSegment = undefined;\n\n    if (new RegExp(MapParser.ARCHIVE_START, \"g\").test(segment)) {\n      activeSegment = \"ARCHIVE\";\n      regexList.push(MapParser.ARCHIVE_REGEX);\n      parseFunction = this.parseArchiveMatch.bind(this);\n    } else if (new RegExp(MapParser.SECTION_START, \"g\").test(segment)) {\n      activeSegment = \"SECTION\";\n      regexList.push(MapParser.SECTION_REGEX);\n      parseFunction = this.parseSectionMatch.bind(this);\n    } else {\n      // WIP, ignore any other segment for now\n      // console.debug(`WIP: skip ${segment}`);\n    }\n    return {\n      Regex: new RegExp(`(${regexList.join(\"|\")})`, \"gm\"),\n      ParseFunction: parseFunction,\n      activeSegment: activeSegment,\n    };\n  }\n\n  parse(content: string): void {\n    let activeSegment: SegmentInfo = {\n      Regex: new RegExp(`(${MapParser.SEGMENT_STARTS_LIST.join(\"|\")})`, \"gm\"),\n      activeSegment: \"START\",\n    };\n\n    let match: RegExpExecArray | null;\n    while ((match = activeSegment.Regex.exec(content)) !== null) {\n      const next_match = match[2];\n\n      if (next_match) {\n        match.shift(); // access actual match\n\n        if (activeSegment.ParseFunction) {\n          activeSegment.ParseFunction(match, activeSegment.Regex, this);\n        } else {\n          console.debug(\n            \"unexpected match, no parsing function provided\",\n            match[0]\n          );\n        }\n      } else {\n        // replace active regex\n        const index = activeSegment.Regex.lastIndex;\n        activeSegment = this.getSegmentRegex(match[1]);\n        activeSegment.Regex.lastIndex = index;\n      }\n    }\n  }\n}\n\nexport default MapParser;\n","import { Alert, AlertTitle, Box, Button } from \"@material-ui/core\";\nimport { useState, VFC } from \"react\";\nimport { FileDrop } from \"react-file-drop\";\nimport { useFilePicker } from \"use-file-picker\";\nimport MapParser from \"../parser/MapParser\";\n\nfunction parseFile(files: FileList | null): Promise<MapParser> {\n  if (files?.length === 1) {\n    const file = files.item(0) as File;\n\n    return file.arrayBuffer().then((buffer: ArrayBuffer) => {\n      // do things\n      console.log(\"lets work on the file size: \", buffer.byteLength);\n\n      let content = \"\";\n      new Uint8Array(buffer).forEach((byte: number) => {\n        content += String.fromCharCode(byte);\n      });\n\n      const parser = new MapParser();\n      parser.parse(content);\n      return parser;\n    });\n  } else {\n    return new Promise((res, rej) => {\n      rej(\"provide one file!\");\n      console.error(files);\n    });\n  }\n}\n\ntype Props = {\n  OnLoaded: (mapParser: MapParser) => void;\n};\n\nconst OutputDrop: VFC<Props> = ({ OnLoaded }) => {\n  const [filesContent, errors, openFileSelector, loading] = useFilePicker({\n    multiple: false,\n    // accept: '.ics,.pdf',\n    accept: [\".map\"],\n  });\n  // TMP\n  openFileSelector;\n  const [dropLoading, setDropLoading] = useState(false);\n  const [dropError, setDropError] = useState<boolean | string>(false);\n  const [filesystemError, setFilesystemError] = useState<boolean | string>(\n    false\n  );\n  const [hover, setHover] = useState(false);\n\n  if (filesContent[0]) {\n    console.log(\n      \"loading through filesystem currently not supported!\",\n      JSON.stringify(filesContent)\n    );\n  }\n\n  return (\n    <div>\n      {errors.length > 0 ? (\n        <Alert onClose={() => (errors.length = 0)} severity=\"error\">\n          <AlertTitle>Error occured while opening file!</AlertTitle>\n          {JSON.stringify(errors)}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {filesystemError ? (\n        <Alert onClose={() => setFilesystemError(false)} severity=\"warning\">\n          <AlertTitle>{filesystemError}</AlertTitle>\n          Drop the file onto the region.\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      {dropError ? (\n        <Alert onClose={() => setDropError(false)} severity=\"error\">\n          <AlertTitle>Loading Dropped file failed!</AlertTitle>\n          {dropError}\n        </Alert>\n      ) : (\n        \"\"\n      )}\n      <FileDrop\n        onDrop={(files) => {\n          setDropLoading(true);\n          parseFile(files)\n            .then(OnLoaded)\n            .catch((err) => setDropError(err))\n            .finally(() => setDropLoading(false));\n        }}\n        onDragOver={() => {\n          if (!hover) {\n            setHover(true);\n            console.log(\"setHover(true)\");\n          }\n        }}\n        onDragLeave={() => {\n          if (hover) {\n            setHover(false);\n            console.log(\"setHover(false)\");\n          }\n        }}\n      >\n        <Box\n          sx={{ p: 0, border: \"1px dashed grey\", m: \"auto\" }}\n          justifyContent=\"center\"\n          justifyItems=\"center\"\n        >\n          <Button\n            disabled={loading || dropLoading}\n            onClick={() => {\n              // openFileSelector()\n              setFilesystemError(\"openFileSelector currently not supported\");\n            }}\n            sx={{ p: 3, m: \"auto\" }}\n            fullWidth={true}\n            style={\n              hover\n                ? {\n                    backgroundColor: \"rgba(63, 81, 181, 0.04)\",\n                  }\n                : {}\n            }\n          >\n            {loading || dropLoading ? \"Loading ...\" : \"Drop output.map here\"}\n          </Button>\n        </Box>\n      </FileDrop>\n    </div>\n  );\n};\n\nexport default OutputDrop;\n","import { SyntheticEvent, useState, VFC } from \"react\";\nimport \"./App.css\";\nimport {\n  Box,\n  Container,\n  Tab,\n  Tabs,\n  Typography,\n  Skeleton,\n} from \"@material-ui/core\";\nimport Table from \"./ui/Table\";\nimport { TabContext, TabPanel } from \"@material-ui/lab\";\nimport OutputDrop from \"./ui/OutputDrop\";\nimport MapParser from \"./parser/MapParser\";\n\nfunction a11yProps(index: number) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\n\nconst TableSkeleton: VFC = () => {\n  return (\n    <div>\n      <Skeleton animation={false} height={64} />\n      <Skeleton variant=\"rectangular\" animation={false} height={500} />\n    </div>\n  );\n};\n\ntype ModulesTableColumns = {\n  Module: string;\n  \"Size no .bss\": number;\n  Size: number;\n  \"Num of records\": number;\n};\ntype ByFilesTableColumns = {\n  File: string;\n} & ModulesTableColumns;\nconst ModulesTableColumnsOrder = [\n  \"Module\",\n  \"Size no .bss\",\n  \"Size\",\n  \"Num of records\",\n];\n\ntype AllTableColumns = {\n  Section: string;\n  SubSection: string;\n  Address: number;\n  AddressHex: string;\n  Size: number;\n  \"Demangled Name\": string;\n  \"Moduled Name\": string;\n  \"File Name\": string;\n  \"Mandled Name\": string;\n};\nconst AllTableColumnsOrder = [\n  \"Section\",\n  \"SubSection\",\n  \"AddressHex\",\n  \"Size\",\n  \"Demangled Name\",\n  \"Moduled Name\",\n  \"File Name\",\n  \"Mandled Name\",\n];\n\ntype TableContentType = string | number;\n\nclass DataTableArray<T extends Record<string, TableContentType>> {\n  Items: TableContentType[][] = [];\n\n  constructor(public ColumnsOrder: string[]) {}\n\n  add(insert: T) {\n    const sorted: TableContentType[] = [];\n    this.ColumnsOrder.forEach((c) => {\n      sorted.push(insert[c]);\n    });\n    this.Items.push(sorted);\n  }\n}\n\nconst formatToHex = (number: number) => {\n  return \"0x\" + `0000000000000000${number.toString(16)}`.slice(-16);\n};\n\nconst App: VFC = () => {\n  const [value, setValue] = useState(\"all\");\n\n  const [allData, setAllData] = useState<TableContentType[][]>([]);\n  const [allModules, setAllModules] = useState<TableContentType[][]>([]);\n\n  const handleChange = (_event: SyntheticEvent, newValue: string) => {\n    setValue(newValue);\n  };\n\n  const fillDatabase = (parser: MapParser) => {\n    const all = new DataTableArray<AllTableColumns>(AllTableColumnsOrder);\n    const allModules = new DataTableArray<ModulesTableColumns>(\n      ModulesTableColumnsOrder\n    );\n    // const byfiles = new\n\n    const notPartOfArchive: ModulesTableColumns = {\n      \"Num of records\": 0,\n      \"Size no .bss\": -1,\n      Module: \"\",\n      Size: 0,\n    };\n    const Archives: { [key: string]: ByFilesTableColumns } = {};\n    Object.keys(parser.Archives).forEach((k) => {\n      Archives[k] = {\n        \"Num of records\": 0,\n        \"Size no .bss\": -1,\n        Module: k,\n        Size: 0,\n        File: parser.Archives[k].File,\n      };\n    });\n\n    // fill all view data\n    // Wip fill module / archive categorisation\n    Object.keys(parser.Sections).forEach((sectionKey) => {\n      parser.Sections[sectionKey].SubSectionsList.forEach((subSections) => {\n        const insert: AllTableColumns = {\n          \"Demangled Name\": \"\",\n          \"File Name\": subSections.FileName,\n          \"Mandled Name\": subSections.Mangled.replace(/$\\.(text|data)/g, \"\"),\n          Address: subSections.StartAddress,\n          AddressHex: formatToHex(subSections.StartAddress),\n          Section: subSections.Section,\n          SubSection: subSections.Name,\n          Size: subSections.Size,\n          \"Moduled Name\": \"\",\n        };\n\n        // WIP, move to parsing process??\n        // select archive for process\n        let partOfModule: ModulesTableColumns = Archives[subSections.FileName];\n        if (!partOfModule) {\n          partOfModule = notPartOfArchive;\n        }\n\n        partOfModule.Size += subSections.Size;\n\n        if (subSections.MangledList.length > 0) {\n          subSections.MangledList.forEach((mangled) => {\n            insert[\"Mandled Name\"] = mangled.MangledName;\n            insert.Size = mangled.Size;\n\n            insert.Address = mangled.AddressStart;\n            insert.AddressHex = formatToHex(mangled.AddressStart);\n            all.add(insert);\n\n            if (mangled.Size > 0) {\n              partOfModule[\"Num of records\"]++;\n            }\n          });\n        } else {\n          if (subSections.Size > 0) {\n            partOfModule[\"Num of records\"]++;\n          }\n\n          all.add(insert);\n        }\n      });\n    });\n\n    allModules.add(notPartOfArchive);\n    Object.keys(Archives).forEach((key) => {\n      // modules.add(Archives[key]) => byFile\n      allModules.add({\n        \"Num of records\": Archives[key][\"Num of records\"],\n        \"Size no .bss\": Archives[key][\"Size no .bss\"],\n        Module: Archives[key].Module,\n        Size: Archives[key].Size,\n      });\n    });\n\n    //console.log(\"res ...\", parser.Archives);\n    setAllData(all.Items);\n    setAllModules(allModules.Items);\n  };\n\n  return (\n    <Container maxWidth=\"lg\">\n      <Box my={4}>\n        <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n          output.map viewer\n        </Typography>\n\n        <OutputDrop OnLoaded={fillDatabase} />\n\n        <TabContext value={value}>\n          <Box sx={{ borderBottom: 1, borderColor: \"divider\" }}>\n            <Tabs\n              value={value}\n              onChange={handleChange}\n              aria-label=\"basic tabs example\"\n            >\n              <Tab label=\"All\" value=\"all\" {...a11yProps(0)} />\n              <Tab label=\"By Module\" value=\"by_module\" {...a11yProps(1)} />\n              <Tab label=\"By File (WIP)\" value=\"by_file\" {...a11yProps(2)} />\n              <Tab\n                label=\"By Section (WIP)\"\n                value=\"by_section\"\n                {...a11yProps(3)}\n              />\n              <Tab\n                label=\"By SubSection (WIP)\"\n                value=\"by_subsection\"\n                {...a11yProps(4)}\n              />\n            </Tabs>\n          </Box>\n          <TabPanel value=\"all\">\n            <Table data={allData} columns={AllTableColumnsOrder} />\n          </TabPanel>\n          <TabPanel value=\"by_module\">\n            <Table data={allModules} columns={ModulesTableColumnsOrder} />\n          </TabPanel>\n          <TabPanel value=\"by_file\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_section\">\n            <TableSkeleton />\n          </TabPanel>\n          <TabPanel value=\"by_subsection\">\n            <TableSkeleton />\n          </TabPanel>\n        </TabContext>\n      </Box>\n    </Container>\n  );\n};\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}